{"componentChunkName":"component---src-templates-index-js","path":"/","result":{"data":{"allMicrocmsArticles":{"edges":[{"node":{"id":"8a9ae7e4-bd09-50a9-b572-28d3db2cff44","slug":"202010-arduino-led","title":"Arduino UNOでフルカラーLED七変化","tags":[{"id":"ifpao4fqr","name":"ハードウェア","slug":"hardware"}],"coverimage":null,"summary":"Arduino UNOにフルカラーLEDを繋いで、PWM調光で光の色合いを自在に変化させます。\nただのLチカではありません。\n","body":"<h2 id=\"hc77b57de51\">あらまし</h2><p>家にある引き出しを漁っていたら、フルカラーLEDを見つけました。<br>このフルカラーLEDをArduino UNOのPWMで光らせれば楽しくなると考え、久しぶりに<br>Arduinoのスケッチを書いてみました。<br></p><h2 id=\"h71f6a51d2d\">ArduinoとArduino UNO</h2><p><a href=\"https://ja.wikipedia.org/wiki/Arduinohttps://ja.wikipedia.org/wiki/Arduino\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipediaの記事</a>による説明では、Arduinoはハードウェアの名称でもあり、開発ソフトウェアや<br>それらを含むコミュニティだとも言われています。<br><br><a href=\"https://www.arduino.cc/\" target=\"_blank\" rel=\"noopener noreferrer\">Arduino公式サイト</a>ではArduinoという名称のハードウェア(コントローラー基板など)を<br>販売してたり、Arduino IDEという開発環境を配布していたりします。<br>その周りに、Arduino IDEをサポートする他社のコントローラーキット (ESP32やSTM32 Nucleo)が存在しています。<br>ESP32, STM32などのマイコンはArduino IDE以外の開発ツールが使えますが、<br>間違いなくArduinoのコミュニティに参画していると言えるでしょう。<br><br>Arduino UNOはArduinoの公式ハードウェアとして最も一般的なもので、<br>16MHzで動く8ビットマイコンのAVR ATmega328Pを搭載しています。<br>また、32kBのフラッシュメモリと2kBのSRAMを搭載しています。<br><br>Arduinoが搭載しているマイコンや記憶素子ではRaspberry PiのようにPC用のOSを動かすことはできませんが、<br>ArduinoはI2CやSPI, UARTといったシリアル通信インターフェース、A&#x2F;Dコンバータ、PWM、割り込み端子を備えています。<br>電子回路をつなげてソフトウェアで制御するという用途ではRaspberry Piにも引けを取らない可能性があり、<br>低消費電力、低発熱に関して言えばRaspberry Piよりもはるかに優位です。<br></p><h2 id=\"h72576d17d2\">Arduino開発環境の用意</h2><p><br>まず<a href=\"https://www.arduino.cc/en/Main/Software\" target=\"_blank\" rel=\"noopener noreferrer\">Arduino公式サイトのダウンロードページ</a>からArduino IDEをダウンロード、インストールします。<br>(ページ内の「Download the Arduino IDE」の見出しのところです。)<br><br>Arduino IDEのインストールが終わったら、Arduino IDEを起動します。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-10%2011.00.21.png\" alt><br>続いてArduino UNOをPCに接続し、仮想シリアルポートの設定を行います。<br>Arduino IDEの「ツール」メニューを開き、ボード一覧から「Arduino UNO」を指定します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-10%2011.32.58.png\" alt><br><br>Arduinoが接続されているシリアルポートを一覧から選択します。<br>「ツール」メニューの「シリアルポート」から、ポートの名前を選択します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-10%2011.34.47.png\" alt><br></p><h2 id=\"h8a3c9ab4de\">ArduinoとLEDの接続</h2><p><br>いったんArduino UNOのボードをPCから外して、<br>以下の回路図の通りに、ArduinoとフルカラーLED, 330オーム抵抗器を接続します。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/schematic.png\" alt><br><br>今回使用したフルカラーLEDはアノードコモン (プラス側の端子が3色で共通) タイプで、<br>抵抗器は330オームのものを使っています。<br></p><h2 id=\"h5d97efe071\">Arduinoのスケッチ</h2><p><br>スケッチのソースコード全体は<a href=\"https://github.com/lazy-joker/arduino/blob/master/sketch_led/sketch_led.ino\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a>にあります。<br>以下はソースコード内の要点になります。<br></p><h3 id=\"h01855d166c\">RGBとHSV</h3><p><br>今回の目論見として、色合いを<br>赤→橙色→黄色→緑→青緑色→青→紫色→赤<br>の順番で1巡させながら、明るさを一定に保つような<br>動作をさせます。<br><br>このような動作をさせるために、スケッチ内で<br><a href=\"https://ja.wikipedia.org/wiki/HSV%E8%89%B2%E7%A9%BA%E9%96%93\" target=\"_blank\" rel=\"noopener noreferrer\">HSV (Hue-Saturation-Value)</a>という色の表現方法を使用します。<br>HSVは手短に言えば色の色相 (色合い)を0°以上360°未満の角度で表し<br>S(彩度)とV(明るさ)を一定にしながら、H(色相)をインクリメントしていきます。<br><br>一方フルカラーLEDの調光はRGBですので、HSVの値をRGBの値に変換する処理が必要です。<br><br>HSV→RGBの変換では、WikipediaのHSV色空間の記事にもあるとおり、<br>Hの値が60°変わるごとに場合分け処理をする必要があります。<br><br>Arduino言語で実装すると、以下のようになります。<br>(コード内のhueが色相 (HSVのうちのH)で、r,g,bが変換後のRGB値です)<br></p><pre><code>\n    if (hue &lt;= 60) {\n      r = 255;\n      g = hue * 255 &#x2F; 60;\n      b = 0;\n    }\n    else if (hue &lt;= 120) {\n      r = (120 - hue) * 255 &#x2F; 60;\n      g = 255;\n      b = 0;\n    }\n    else if (hue &lt;= 180) {\n      r = 0;\n      g = 255;\n      b = (hue - 120) * 255 &#x2F; 60;\n    }\n    else if (hue &lt;= 240) {\n      r = 0;\n      g = (240 - hue) * 255 &#x2F; 60;\n      b = 255;\n    }\n    else if (hue &lt;= 300) {\n      r = (hue - 240) * 255 &#x2F; 60;\n      g = 0;\n      b = 255;\n    }\n    else {\n      r = 255;\n      g = 0;\n      b = (360 - hue) * 255 &#x2F; 60;\n    }</code></pre><p>(上記のコードではS=100%, V=100%で一定を前提に作っています。<br> S,Vの値が100%以外の値を取りうる場合は、コード内の数式がもう少し複雑になります。)<br></p><h3 id=\"hf4e9abd19e\">PWM出力による調光</h3><p><br><a href=\"https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%AB%E3%82%B9%E5%B9%85%E5%A4%89%E8%AA%BF\" target=\"_blank\" rel=\"noopener noreferrer\">PWM(パルス幅変調)</a>とは、一定周期の矩形波(方形波)を出力しながら<br>矩形波のHIGHレベルを出力している長さの割合(デューティ比)を<br>入力(アナログ信号や数値)によって変化させる動作です。<br><br>Arduinoでは5つのディジタル出力端子でPWM動作をすることができ、<br>各々のPWMの入力値はプログラム中のanalogWrite()関数で指定します。<br><br>analogWrite()は0〜255の範囲で入力値を受け付け、<br>入力が0のとき常にLOW(0V)を出力、入力が255のとき常にHIGH(+5V)を出力します。<br>0〜255の間の値では「入力×100&#x2F;255」[%] のデューティ比で矩形波を出力します。<br><br>ここで一つ注意が必要なのは、<br>今回のLED接続ではPWM出力は負論理になることです。<br>つまり、PWM出力がHIGHのときはLEDは光らず<br>PWM出力がLOWのときだけLEDが光ります。<br><br>そのため、analogWrite()で指定するPWM出力レベルは、<br>以下のように255からRGB値を引いた数とします。<br></p><pre><code>    analogWrite(3, 255 - r);\n    analogWrite(5, 255 - g);\n    analogWrite(6, 255 - b);  </code></pre><p><br></p><h2 id=\"h75b359be50\">実際に光らせてみた</h2><p>スケッチのコードをArduino IDEに入力して書き込みボタンを押すと<br>Arduino UNO基板上でプログラムが動作し始めます。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-10%2013.58.04.png\" alt><br><br><br>実際に光らせたときの動画は<a href=\"https://twitter.com/wannabee1985/status/1309736379337768960\" target=\"_blank\" rel=\"noopener noreferrer\">Twitter</a>で公開しています。<br></p><h2 id=\"ha214098e44\">まとめ</h2><p>この記事では</p><ul><li>Arduinoの概要</li><li>Arduino IDEのインストール</li><li>ArduinoUNOとの接続セットアップ</li><li>フルカラーLEDを調光するスケッチ作成と実行</li></ul><p>について述べました。<br><br>ArduinoのPWM出力はLEDの調光以外にも<br>モーターの制御など様々な用途があります。<br><br>今回は取り上げませんでしたが、Arduinoにはシールドという<br>拡張基板がサードパーティにより設計・製造されております。<br>(<a href=\"https://akizukidenshi.com/catalog/c/carduino2/\" target=\"_blank\" rel=\"noopener noreferrer\">秋月電子</a>、<a href=\"https://www.switch-science.com/catalog/list/42/\" target=\"_blank\" rel=\"noopener noreferrer\">スイッチサイエンス</a>などのオンライン店舗でも販売されています)<br>  (秋月電子のページでセッションのエラーが起きた場合はブラウザで再読み込みしましょう)<br><br>シールドには通信インターフェースの追加やモーターの駆動など<br>様々な機能を提供しています。これらシールドによる拡張性も<br>Arduinoプラットフォームの大きな特長と言えるでしょう。<br></p><h3 id=\"h727521698e\">おっさんの小言 : 昔は大変だった</h3><p><br>Arduino以前のマイコン開発では、マイコンを動作させるための回路と<br>制御対象の周辺回路は一括で、一品ものとして作るのが主でした。<br><br>マイコンの書き込みも、一旦書き込み専用回路(ROMライタ)に<br>マイコンチップを載せ替えてから書き込みを行い、<br>その後また基板を載せ替えて動かす場合も多かったのです。<br><br>今のように試しに動かしてみながら微修正を加えていくようなことは、<br>当時はひどく面倒で非現実的だったのです。<br>(2000年代前半のPICやH8の制作例を見れば、当時の電子工作趣味人の苦労が偲ばれるでしょう。)<br><br>私見ですがArduinoの登場した頃になってから、マイコンの周辺回路と<br>制御対象を「別々のモジュールとして作り」「組み合わせて」<br>使うことが一般的になったように思えます。<br>この流れのおかげで、マイコン電子工作は昔よりも<br>非常に容易に、手軽に試せるものになりました。<br><br>ソフトウェアの世界のように、PCさえあれば<br>大抵何でもできるというほどではありません。<br>しかしながら高度な専門知識を持った人が<br>工具一式を揃えて初めてスタートラインに立てる、<br>というようなものではなくなりました。<br></p>"}},{"node":{"id":"a279a651-88fe-5468-bed8-9c6c013ef776","slug":"202010-raspi-bot","title":"Raspberry PiでDiscordボットを作る(2) センサの接続とボットプログラムの作成","tags":[{"id":"ifpao4fqr","name":"ハードウェア","slug":"hardware"},{"id":"qmlwx8ehn","name":"IoTデバイス","slug":"iot-device"}],"coverimage":null,"summary":"Raspberry Piで、I2Cセンサの読み値をDiscordでつぶやくボットを実行させる方法です。\n前回Raspberry PiにSSHで接続できるようになったところから続きです。","body":"<h2 id=\"hc77b57de51\">あらまし</h2><p><a href=\"https://proactive-cybernetics.netlify.app/article/202009-raspi-os\" target=\"_blank\" rel=\"noopener noreferrer\">前回の記事</a>でRaspberry Piにリモートログインができるようになったところから、<br>本格的にRaspberry Piらしいことをしていこうと思います。<br><br>今回は、Raspberry PiでI2C接続のセンサから測定値を読み取る方法と、<br>センサから読み取った測定値をチャットサービス(<a href=\"https://discord.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Discord</a>)に投稿するボットを作る方法を説明します。<br></p><h2 id=\"hfb91fd38fa\">I2C環境センサについて</h2><p>I2Cとは、<a href=\"https://ja.wikipedia.org/wiki/I2C\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipediaの記事</a>にあるように1つのコントローラ(マイコンなど)と、1個または多数の周辺機器を接続する<br>シリアル式のバス接続規格です。<br>I2Cは「アイ・スクェアド・シー」または「アイ・トゥ・シー」と読まれることが多いです。<br><br>今回使うI2C接続のセンサとして、<a href=\"https://akizukidenshi.com/catalog/g/gK-14469/\" target=\"_blank\" rel=\"noopener noreferrer\">Boshe BME680環境センサ</a>を購入しました。<br>このセンサでは温度と湿度、気圧の測定が行えます。<br><br>秋月電子の通販で買ったものではセンサ素子の乗った基板とブレッドボードに挿せるピンヘッダが付属していましたが、<br>自分でピンヘッダを基板にはんだ付けする必要がありました。<br>(はんだ付けの技術については、本記事では割愛します。)<br></p><h2 id=\"h3ea3cca820\">Raspberry PiでI2Cを有効化する</h2><p>Raspberry PiのI2Cはデフォルトで無効になっていますので、有効化の設定を行います。<br><br>まず、aptパッケージマネージャでi2c-toolsパッケージをインストールします。</p><pre><code>sudo apt install i2c-tools</code></pre><p><br>次に、raspi-configツールからi2cの設定を有効にします。</p><pre><code>sudo raspi-config</code></pre><p><br>raspi-configのメニュー画面から、矢印キーで「5 Interfacing Options」を選択してEnterキーを押します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-07%2021.52.31.png\" alt><br><br>Interfacing Optionsのメニューに入るので、「P5 I2C」を選択してEnterキーを押します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-07%2021.55.15.png\" alt><br><br>「はい」を選択します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-07%2021.55.57.png\" alt><br><br>I2Cが有効化された旨が表示されます。raspi-configのメニューから「Finish」でメニューを閉じて次に進みます。<br></p><h2 id=\"h9142ef6055\">Raspberry Piにセンサを接続</h2><p><br>まず、Raspberry Piの電源を切ります。</p><pre><code>sudo shutdown -h now</code></pre><p>コマンドを実行し、しばらくしたら電源用USBケーブルをRaspberry Pi本体から引き抜きます。<br><br>Raspberry Piのピンヘッダに、環境センサの各端子をジャンパワイヤで接続します。<br><br>Raspberry Pi    環境センサ<br>+5V (2)         ---        VIN (1)　(※ カッコ内はピン番号)<br>SCL (5)         ---        SCL (2)<br>SDA (3)         ---        SDA (3)<br>GND (6)         ---        GND (4)<br><br>接続ができたら、Raspberry Piに電源用USBを挿入して起動します。<br>Raspberry Piが起動したら、PCからSSHでRaspberry Piにログインします。<br></p><h2 id=\"h0e869fb9b5\">センサの動作確認</h2><p>再起動とログインができたら、i2cdetectコマンドを実行します。<br>以下のように「77」(BME680のI2Cアドレス) が表示されればセンサが接続できています。</p><pre><code>$ sudo i2cdetect -y 1\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:          -- -- -- -- -- -- -- -- -- -- -- -- -- \n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n70: -- -- -- -- -- -- -- 77</code></pre><p><br>続いて、Pythonプログラムからセンサの値を読み取ってみましょう。<br></p><pre><code>git clone https:&#x2F;&#x2F;github.com&#x2F;pimoroni&#x2F;bme680-python.git\ncd bme680-python&#x2F;examples\nsudo pip3 install bme680\npython3 read-all.py</code></pre><p><br>以下のようにセンサから取得した値が表示されれば成功です。<br>(出力は一例です。数値はセンサの物理的環境によって異なります。)</p><pre><code>$ python3 read-all.py \nread-all.py - Displays temperature, pressure, humidity, and gas.\n\nPress Ctrl+C to exit!\n\n(中略)\n\nPolling:\n25.25 C,1014.70 hPa,70.11 %RH\n25.26 C,1014.71 hPa,70.07 %RH,3712.5851520667234 Ohms\n25.30 C,1014.73 hPa,70.00 %RH,6040.203089121114 Ohms\n25.33 C,1014.71 hPa,69.91 %RH,8579.990372223523 Ohms\n25.37 C,1014.70 hPa,69.83 %RH,11141.141109863216 Ohms</code></pre><p><br>キー割り込み(Ctrl-c)操作でスクリプトの実行を停止します。<br><br>ここまで出来たら、いよいよI2Cセンサの測定値をつぶやくDiscordボットの作成に入ります。<br></p><h2 id=\"h37245156f0\">Discordボットの作成 : 自分専用サーバーの作成とボットの登録</h2><p>Discordボットを動かすための、自分専用のサーバーを作ります。<br><br>まず、Discordアプリを開いて「サーバーを追加」を選択します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-06%2022.15.09.png\" alt><br><br>「サーバーを作成」画面で「Create my own」を選びます。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-06%2022.16.53.png\" alt><br><br><br>サーバー名を入力し、「新規作成」を押します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-06%2022.18.17.png\" alt><br></p><h3 id=\"h830f7115b8\">Discordサーバーにボットを招待する</h3><p>あとは、新しく作ったサーバーにボットを招待します。<br><a href=\"https://discordpy.readthedocs.io/ja/latest/discord.html\" target=\"_blank\" rel=\"noopener noreferrer\">discord.pyの公式サイト</a>にボットのアカウント作成方法がありますので、ページに示された手順に従って<br>ボットのOAuth設定と、ボットのサーバーに対する権限の設定を行います。<br>権限を適切に設定しないと、ボットがサーバーに投稿しない、もしくはボットがユーザーの投稿に反応できないことがありますので注意しましょう。<br><br>Discordのサイトの、ボットの設定ページ内にあるボットのトークンを控えておきます。<br><br>また、ボットが投稿するためのチャンネルを作成し、作成したチャンネルのIDを控えておきます。<br>チャンネルのIDは<a href=\"https://support.discord.com/hc/ja/articles/206346498-%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC-%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8ID%E3%81%AF%E3%81%A9%E3%81%93%E3%81%A7%E8%A6%8B%E3%81%A4%E3%81%91%E3%82%89%E3%82%8C%E3%82%8B-\" target=\"_blank\" rel=\"noopener noreferrer\">こちら</a>に記された手順で確認できます。<br></p><h2 id=\"h22b6b12c88\">DiscordボットのためのPythonの設定</h2><p>venvによるPythonの仮想環境を作成し、その中でPIPパッケージのインストールを行います。<br>まず、作業用ディレクトリを作成します。</p><pre><code>mkdir ~&#x2F;work&#x2F;discordbot\ncd ~&#x2F;work&#x2F;discordbot</code></pre><p><br>作業用ディレクトリに入ったら、venvコマンドでPythonの仮想環境を作ります。</p><pre><code>python3 -m venv .\nsource bin&#x2F;activate</code></pre><p><br>activateスクリプトを呼び出すとプロンプトの形が変わります。<br>この状態で、pipコマンドでパッケージを導入します。<br>導入するパッケージはbme680 (I2C環境センサの制御)と、discord.py (Discordボット用ライブラリ)です。</p><pre><code>pip install bme６８０\npip　install discord.py</code></pre><p><br>「.env」隠しファイルを作成し、その中にボットのトークンと投稿先チャネルのIDを含めます。</p><pre><code>touch .env\necho BOT_TOKEN=*********************** &gt;&gt; .env\necho SANDBOX_CHANNEL_ID=******** &gt;&gt; .env</code></pre><p><br>.envファイルはくれぐれもリポジトリにコミットしないようにしましょう。<br>Gitを使っていれば、.gitignoreファイルに「.env」を追加します。</p><pre><code>echo .env &gt;&gt; .gitignore</code></pre><p><br></p><h2 id=\"haddfa43deb\">ボットの実装</h2><p>ボットをPythonプログラム (example_bot.py)で実装します。</p><pre><code>import discord\nfrom discord.ext import tasks\nimport bme680tph\n\t\n# 環境設定 (.env　ファイル) 用\nimport os\nfrom os.path import join, dirname\nfrom dotenv import load_dotenv\n\t\n@client.event\nasync def on_ready():\n    print (&#x27;We have logged in as {0.user}&#x27;.format(client))\n    await client.get_channel(sandbox_channel_id).send(&#x27;こんにちは&#x27;)\n\n@client.event\nasync def on_message(message):\n    print(&#x27;on_message:{0}&#x27;.format(message.content));\n    if message.author.bot:\n        return\n    if message.content.startswith(&#x27;$hello&#x27;):\n        await message.channel.send(&#x27;よぅ!&#x27;)\n    if message.content.startswith(&#x27;$室温&#x27;):\n        await message.channel.send(bme680tph.get_sensor())\n\nif __name__ == &quot;__main__&quot;:\n　　　　load_dotenv(verbose=True)\n　　　　sandbox_channel_id = int(os.environ.get(&quot;SANDBOX_CHANNEL_ID&quot;))\n　　　　bot_token = os.environ.get(&quot;BOT_TOKEN&quot;)\n\n　　　　client = discord.Client()\n    client.run(bot_token)</code></pre><p><br>見ての通り、プログラムは、「@client.event」デコレータがつけられた2つの関数と<br>「if __name__==&quot;__main__&quot;:」ブロックからなります。<br><br>on_ready関数はdiscord.pyで作成したclient(ボット)がDiscordサーバーに正常に接続できた時に呼び出され、<br>on_message関数はclientが接続しているサーバーに誰かが投稿した時に呼び出されるコールバック関数です。<br><br>「if __name__==&quot;__main__&quot;:」直後の3行は.envファイルから設定(投稿先のチャンネルIDとボットのトークン)<br>を読み出す処理です。<br>最後の2行でclientを作成し、ボットの動作を開始しています。<br><br><br>センサーから気温、湿度と気圧を取得する手続きを記した<br>bme680tph.py ファイルを作成し、example_bot.pyと同じディレクトリに置きます。<br>このbme680tph.pyはpimoroni氏の提供によるライブラリ(<a href=\"https://pypi.org/project/bme680/\" target=\"_blank\" rel=\"noopener noreferrer\">PyPI bme680モジュール</a>) を使用して作成しています。<br></p><pre><code>import bme680\n\ntry:\n    sensor = bme680.BME680(bme680.I2C_ADDR_PRIMARY)\nexcept IOError:\n    sensor = bme680.BME680(bme680.I2C_ADDR_SECONDARY)\n\t\n\n# These oversampling settings can be tweaked to\n# change the balance between accuracy and noise in\n# the data.\t\n\nsensor.set_humidity_oversample(bme680.OS_2X)\nsensor.set_pressure_oversample(bme680.OS_4X)\nsensor.set_temperature_oversample(bme680.OS_8X)\nsensor.set_filter(bme680.FILTER_SIZE_3)\n\t\n\ndef get_sensor():\n    if sensor.get_sensor_data():\n        output = &quot;&quot;&quot;温度 : {0:.2f} [°C],\n気圧 : {1:.2f} [hPa],\n湿度 : {2:.3f} [%RH]&quot;&quot;&quot;.format(\n            sensor.data.temperature,\n            sensor.data.pressure,\n            sensor.data.humidity)\n        return(output)</code></pre><p><br>このプログラムを実行し、Discordアプリからボットの投稿用チャネルを開いて<br>「こんにちは」と投稿されていることを確認します。</p><pre><code>python3 example_bot.py</code></pre><p><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-06%2022.48.04.png\" alt><br><br>また、「$hello」と投稿して、ボットが「よぅ!」と返事すること、<br>「$室温」を投稿して、ボットが気温と湿度、気圧を応答することを確認します。<br>もしボットによる投稿が確認できなかったら、ボットを起動したターミナルにエラー出力がないか確認します。<br>(なお私はon_message関数のスペルを1文字間違えたためにボットが応答せず、数時間もの間苦悶の表情を浮かべて「どおしてだよおぉぉ」と唸っていました。)<br><br>動作確認ができたら一回ボットを停止します。ボットはキーボード割り込み(Ctrl-c)で停止します。<br></p><h3 id=\"h40ea9a7213\">一定時間ごとに定期投稿する</h3><p><br>次に、ボットに手続きを追加して、1時間ごとに気温と湿度、気圧を投稿するようにします。<br>example_bot.pyに新しく関数loopを追加します。<br></p><pre><code>@tasks.loop(seconds=60)\nasync def loop():\n    # 現在の時刻 : 00分のときのみセンサの値を送信\n　   print(datetime.now().strftime(&#x27;%H:%M&#x27;))\n    if datetime.now().strftime(&#x27;%M&#x27;) == &#x27;00&#x27;:\n        await client.get_channel(sandbox_channel_id).send(&#x27;定期送信\\n&#x27;+bme680tph.get_sensor())</code></pre><p><br>関数loopに付けられたtasks.loopデコレータは、loop関数を一定時間ごとに実行するために付けています。<br>毎時00分に、bme680tph.pyの関数を呼び出して気温と湿度、気圧を投稿します。<br><br>続いて、clientの開始直後にloop関数の周期実行を開始させます。<br>example_bot.pyの末尾にloop.start()を追加します。</p><pre><code>    client = discord.Client()\n    client.run(bot_token)\n    loop.start()</code></pre><p><br>定期実行が正しく行われれば、1時間ごとに「定期送信」で始まる投稿がされるようになります。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-07%2022.10.16.png\" alt><br></p><h2 id=\"ha214098e44\">まとめ</h2><p><a href=\"https://proactive-cybernetics.netlify.app/article/202009-raspi-os\" target=\"_blank\" rel=\"noopener noreferrer\">第1回</a>と本記事で、以下の内容を取り上げました。<br><br>第1回</p><ul><li>Raspberry Pi OSについて<ul><li>Raspberry Pi OSイメージのダウンロードと検証</li><li>Raspberry Pi OSイメージのmicroSDへの書き込み</li><li>Raspberry Piの起動</li></ul></li><li>Raspberry Piのネットワークログイン設定<ul><li>マルチキャストDNSの導入</li><li>SSHの有効化</li></ul></li></ul><p><br>第2回</p><ul><li>I2C接続のセンサについて</li><li>I2C接続のセンサをPythonプログラムから使う</li><li>Discord.pyによるボットの作成<ul><li>ボットが定期投稿を行うようにする</li></ul></li><li>Discordサーバーの新規作成とボットの招待</li></ul><p><br>次回はやるかどうか未定ですが、出来たらHeroku上のカスタムサーバに<br>センサの測定値を定期的に送信して、気温・湿度と気圧のグラフをWebブラウザから確認できるようにしたい<br>などと考えております。<br></p>"}},{"node":{"id":"f01a9a19-6197-5965-ad1f-3148383a4b76","slug":"202009-making-new-blog","title":"メイキング・オブ・新ブログ","tags":[{"id":"nuhf_nqws","name":"Webフロント","slug":"web-front"}],"coverimage":{"url":"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/220787.png"},"summary":"このブログの作り方です。Gatsby.js+microCMS+Netlifyで作りました。","body":"<p>本記事では、microCMS、Gatsby.jsとNetlifyを使って本ブログを作成した方法について説明します。<br><br>説明の流れは</p><ul><li>ヘッドレスCMSの選定 (いかにしてmicroCMSを使うようになったか)</li><li>microCMSのAPI設定</li><li>Gatsby.jsによるサイト構築</li><li>Netlifyによるサイトの公開</li></ul><p>となります。<br></p><h2 id=\"ha8b7adfcd5\">MicroCMSを選んだ理由</h2><p><a href=\"https://proactive-cybernetics.netlify.app/article/202009-gave-up-migration\">前回の記事</a>でWordpress製ブログの移行を断念してから、最初からヘッドレスCMSとして作られているサービスを使ってGatsby製ブログを作ろうと考えましたが、<br>その矢先「ヘッドレスCMS, 意外とたくさんある」という事実に突き当たりました。<br><br>当初、一番安牌と考えていたのはNetlify CMSでした。当初からGatsby製サイトをNetlifyで公開しようとしていたので<br>Netlifyでお膳立てされたサービスですべてを完結すれば、簡単にサイトが作れる算段です。<br>ContentfulもヘッドレスCMSの中で「鉄板」の地位を築いているように見えました。ユーザー数もノウハウの蓄積もピカイチです。<br>一方、日本発のmicroCMSというサービスがあることを聞き及んでいました。<br><br>結局、以下の2点からmicroCMSを選びました。</p><ul><li>日本語のドキュメントが整備されている</li><li>最低限必要な機能が整ったシンプルなUI</li></ul><p>とくに管理画面のUIのシンプルさはヘッドレスCMS初心者の私を安心させてくれました。<br>microCMSのリッチエディタも、Wordpressのエディタとあまり変わらない使い勝手でした。<br></p><h2 id=\"h3f2e353ce2\">microCMS APIの作成</h2><p>microCMSを使うことが決まったところで、microCMSで新規のサービスを作ります。<br>(サービスの作成方法は、<a href=\"https://microcms.io/docs/manual/create-service\" target=\"_blank\" rel=\"noopener noreferrer\">microCMSの公式マニュアル</a>を参照)<br><br>次に、microCMSで管理するコンテンツAPIを作成します。<br>当サイトのmicroCMSコンテンツでは、以下の4つのAPIについて定義を作りました。<br></p><ul><li>記事</li><li>タグ</li><li>固定ページ</li><li>リンク集</li></ul><p><br>APIを追加するには、microCMS左側の「コンテンツ(API)」の右隣の「+」をクリックします。<br>続いて「APIの基本情報を入力」画面でAPI名とエンドポイントURLを指定します。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-01%2020.41.59.png\" alt><br><br>APIの型は「リスト形式」を選択します。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-10-01%2020.42.14.png\" alt><br><br>APIの型を選択したら、最後にAPIのスキーマ(データの形式)を設定します。<br>例として、記事APIのスキーマ定義を以下に示します。<br></p><ul><li>フィールドID : title, 表示名 : タイトル, 種類 : テキストフィールド</li><li>フィールドID : summary, 表示名 : 要約, 種類 : テキストエリア</li><li>フィールドID : body, 表示名 : 本文, 種類 : リッチエディタ</li><li>フィールドID : writer, 表示名 : 著者, 種類 : テキストフィールド</li><li>フィールドID : slug, 表示名 : URIスラッグ, 種類 : テキストフィールド</li><li>フィールドID : tags, 表示名 : タグ, 種類 : 複数コンテンツ参照 - タグ</li></ul><p><br>最後のタグのフィールドがタグAPIの定義に依存しているので、記事APIにタグフィールドを追加する前にタグAPIを作っておく必要があります。<br><br>記事、タグ、固定ページ、リンク集のAPI定義を作成したら、Gatsbyでサイトを構築する作業に入ります。<br></p><h2 id=\"h47b07cf818\">Gatsbyでサイトを構築</h2><p>microCMSのAPI定義に続いて、Gatsbyでのサイト構築に入ります。<br>(現在のサイト生成コードの最新版は<a href=\"https://github.com/lazy-joker/og-blog-mcms\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a>に上げています。)<br><br>gatsby-source-microcmsを使ったサイトの構築にあたり、りゅーそうさんのnote記事<br>(<a href=\"https://note.com/youheyhey0505/n/nc7fdd9de7c89\" target=\"_blank\" rel=\"noopener noreferrer\">前編</a>・<a href=\"https://note.com/youheyhey0505/n/n0593d5478a10\" target=\"_blank\" rel=\"noopener noreferrer\">後編</a>) を大いに参考にさせていただきました。<br><br>まずLinuxのコマンドラインから「gatsby new」コマンドで新規プロジェクトを作り、その上で<a href=\"https://www.gatsbyjs.com/plugins/gatsby-source-microcms/\" target=\"_blank\" rel=\"noopener noreferrer\">gatsby-source-microcms</a>パッケージを追加します。<br></p><pre><code>gatsby new\nnpm install gatsby-source-microcms</code></pre><p><br>microCMSのコンテンツを取り込むため、<a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/gatsby-config.js\" target=\"_blank\" rel=\"noopener noreferrer\">gatsby-config.js</a>に<br>gatsby-source-microcmsパッケージの設定を加えます。<br></p><pre><code>    {\n\t      resolve: &quot;gatsby-source-microcms&quot;,\n\t      options: {\n\t        apiKey: process.env.MICROCMS_API,\n\t        serviceId: &quot;og-blog&quot;,\n\t        apis: [\n\t          {\n\t            endpoint: &quot;articles&quot;,\n\t          },\n\t          {\n\t            endpoint: &quot;tags&quot;,\n\t          },\n\t          {\n\t            endpoint: &quot;links&quot;,\n\t          },\n\t          {\n\t            endpoint: &quot;pages&quot;,\n\t          },\n\t        ],\n\t      },</code></pre><p><br>以下、下図のサイト構成でページを作っていきます。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/sitemap.jpeg\" alt><br></p><h3 id=\"h4fe16b8a4a\">トップページ (index)</h3><p>トップページ(<a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/src/templates/index.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/templates/index.js</a>)には、各記事の概要 (タイトル、要約、公開日、タグ) が表示されるようにしました。<br>トップページの各記事の概要のリンクから、各記事のページが見られるようにしています。<br><br>またトップページを含む全てのページの右側には、メニューバーが表示されるようにしました。<br>ページ右側のメニューバーには、ブログの扱うタグ一覧、固定ページの一覧とリンク集が表示されるようにしました。<br>(メニューバーの表示は <a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/src/components/rightmenu.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/components/rightmenu.js</a> で定義したコンポーネントを使いました。)<br></p><h3 id=\"hf8ed3c5608\">記事 (article)</h3><p><a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/src/templates/blog-article.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/templates/blog-articls.js</a>にて、各記事の詳細ページを生成しています。<br>各記事の詳細ページでは、記事本文の全文が表示されます。<br><br>各記事のURLは、microCMS側で各記事に設定しているslug (スラッグ : URLに含めるための英数字の略称) を使って</p><pre><code>&#x2F;article&#x2F;&lt;記事のslug&gt;</code></pre><p>としています。<br></p><h4 id=\"h3e69a02751\">記事のSNSシェアボタン</h4><p>この記事の下方にもありますが、SNSシェアボタン (Twitter, Line, LinkedIn, Facebook) を<br>各記事に設けています。<br>SNSシェアボタンの設置には、<a href=\"https://www.npmjs.com/package/react-share\" target=\"_blank\" rel=\"noopener noreferrer\">react-share</a>パッケージを使用しました。<br></p><h3 id=\"h45efd70457\">タグ (tag)</h3><p>microCMS側で、1つの記事に複数のタグを付けられるように設定したうえで、<br>各タグのインデックスページ</p><pre><code>&#x2F;tag&#x2F;&lt;タグのslug&gt;</code></pre><p>を作りました。<br><br>各タグのインデックスページに、該当タグの含まれるすべての記事の概要を<br>表示するようにしています。<br>各タグの情報と、各タグに対応する記事一覧を取得するGraphQLクエリは<br><a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/src/templates/tag-index.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/templates/tag-index.js</a>の変数queryの値を使って取得しています。<br></p><h3 id=\"ha7242b0a94\">固定ページ (page)</h3><p><a href=\"https://github.com/lazy-joker/og-blog-mcms/blob/master/src/templates/static-page.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/templates/static-page.js</a>では、各固定ページの内容を表示するページを生成します。<br></p><h3 id=\"h5415d563f5\">サイトの動作確認</h3><p><br>作成途中での部分的な確認は</p><pre><code>gatsby develop</code></pre><p><br>を実行し、ブラウザでlocalhost:8000を開きます。<br>GraphQL絡みの修正をしない限り、jsファイルの修正はブラウザの表示に自動的に適用されます。<br>GraphQLのクエリなどを変更した場合はCtrl-cキー操作でいったんdevelop動作を抜けて、再度developを実行します。<br><br>パフォーマンステストなど本格的な確認は</p><pre><code>gatsby build\ngatsby serve</code></pre><p><br>を実行し、ブラウザでlocalhost:9000を開きます。<br></p><h3 id=\"he22bb1aa2e\">microCMSのAPI認証キーの取り扱い</h3><p>Githubにコミットする前に、microCMSのAPI認証キーを<br>Githubにコミットするコードから外し、「.env」隠しファイルでキーを管理するようにします。</p><pre><code>npm install --save dotenv</code></pre><p><br>gatsby-config.jsのapiKeyの部分を以下のように変更し、dotenvパッケージを呼び出すようにします。</p><pre><code>      apiKey: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,</code></pre><p>↓</p><pre><code>require(&#x27;dotenv&#x27;).config()\n\n...(中略)...\n\n      apiKey: process.env.MICROCMS_API,</code></pre><p><br>.env 隠しファイルには、APIキーを以下のように入れておきます。</p><pre><code>MICROCMS_API=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></pre><p><br>.envファイルはリポジトリにコミットしないよう、.gitignoreの設定を忘れずしておきます。</p><pre><code>echo .env &gt;&gt; .gitignore</code></pre><p><br>GatsbyのプロジェクトをGithubにコミットしたら、Netlifyにログインします。<br></p><h2 id=\"hd6f5d00ae8\">Netlifyでサイトを公開</h2><p>作成したサイトをNetlifyで公開します。リポジトリを登録して環境変数を設定しておくだけで<br>Gatsbyで作成したサイトのビルドが始まり、数分でサイトの公開まで完了します。<br></p><h3 id=\"hdbf1dcc7cc\">リポジトリの設定</h3><p>Netlifyにログインして、「Sites」のNew site from Git」を選択します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-09-30%2020.26.32.png\" alt><br><br>「Github」を選択し、Gatsbyのプロジェクトのリポジトリを選択します。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-09-30%2020.28.12.png\" alt><br></p><h3 id=\"hbe726b3449\">環境変数の設定</h3><p>Githubのリポジトリの選択まで終わったら、ビルド方法の設定に入ります。<br>「Deploy site」の前に、「Show advanced」から環境変数の設定に入ります。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-09-30%2020.31.44.png\" alt><br><br>「Show advanced」を押すと「New variable」ボタンが現れるので<br>「New variable」ボタンを押して環境変数MICROCMS_APIを追加します。<br>MICROCMS_APIの値 (Value) は、.envファイルで指定したのと同じ値にします。<br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202020-09-30%2020.35.58.png\" alt><br><br>最後に「Deploy site」ボタンをクリックするとNetlifyのサーバでサイトのビルドが行われます。<br>ビルドは数分で完了し、その後はNetlifyで割り当てられたサイト名でサイトが公開されます。</p>"}},{"node":{"id":"bc94f101-29ae-5ed6-b212-b47c7da489e3","slug":"202009-gave-up-migration","title":"Gatsby.jsの学習とWordpressヘッドレス化の顛末","tags":[{"id":"nuhf_nqws","name":"Webフロント","slug":"web-front"}],"coverimage":{"url":"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/Gatsby_Logo.png"},"summary":"Gatsby.jsのチュートリアルを進めた記録と、Wordpressに移行しようとして断念したときの経緯についてです。","body":"<h2 id=\"hd64ea1b853\">事の起こり</h2><p>コロナ禍の2020年も半ばを過ぎたころ、静的サイトジェネレータのGatsby.jsというものでサーバーを立てずにブログを運用できると聞きました。ちょうどWebフロントエンドのポートフォリオが欲しいと思っていたこともあり、Gatsby.jsで自分の新しいブログを作りたいと思いました。<br><br>ブログを移転しようと思ったのは、ポートフォリオが欲しかったこともありますが、Wordpressの無料テーマにめぼしいデザインがなく、かと言って今更Wordpressの作りを覚えてまでオリジナルのテーマを書く気になれなかったというのが理由です。<br></p><h2 id=\"hdded1eef50\">Gatsby公式チュートリアル</h2><p>まず<a href=\"https://www.gatsbyjs.com/tutorial/\" target=\"_blank\" rel=\"noopener noreferrer\">Gatsbyの公式チュートリアル</a>をやってみました。公式チュートリアルは英語でしたが、Qiitaにチュートリアルを進める過程を日本語で説明した<a href=\"https://qiita.com/3S_Laboo/items/a38536ed1fb976303b47\" target=\"_blank\" rel=\"noopener noreferrer\">記事</a>があったので、英語のチュートリアルとQiitaの記事を見比べながら進めました。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/Ehln2MMXkAAbbzp.jpg\" alt><br></p><h2 id=\"hd40142a3e3\">既存のWordpressサイトをGatsbyに移行 (断念)</h2><p>チュートリアルを終えたところで、私の<a href=\"https://rclab.wp-x.jp/\" target=\"_blank\" rel=\"noopener noreferrer\">Wordpress製ブログ</a>をGatsbyに移行する試みをしました。<br>これまでの記事を書き換える手間を考えたところで断念しましたが、記録を以下に残します。<br></p><h3 id=\"hfab2e7b4e1\">使用したstarter</h3><p>Starterには<a href=\"https://www.gatsbyjs.com/starters/GatsbyCentral/gatsby-starter-wordpress\" target=\"_blank\" rel=\"noopener noreferrer\">gatsby-starter-wordpress</a>を使いました。<br></p><h3 id=\"h6e8e0d2a6a\">断念の経緯</h3><p>当初、WordpressからGatsbyへの移行は以下のステップで進めようと考えていました。</p><ol><li>Gatsbyで作ったサイトをNetlifyで公開しながら、Wordpressのサイトは公開を継続</li><li>Wordpressのサイトをヘッドレス化して、Gatsbyで作ったサイトだけ公開する</li></ol><p><br>しかし、以下の3点の理由から1.の状態での運用を断念しました。</p><ul><li>CSSの問題 : Wordpress側のスタイル指定をGatsby側で上書きする方法がわからない</li><li>既存の記事のリンクの問題 : Wordpress内で作った記事内の、Wordpress内の他のページへのリンクをGatsbyのサイトへのリンクに差し替えないといけなくなった</li><li>Wordpressプラグインの問題 : 今まで使っていたプラグインで作っていた目次が、Gatsby側ではうまく表示されない</li></ul><p><br>上記の問題からWordpress製ブログの移行&amp;ヘッドレス化はあきらめ、代わりに生粋のヘッドレスCMSを使って新しいブログを作ることにしました。<br><br>次回に続きます。</p>"}},{"node":{"id":"649b3092-ec85-52d2-b2b9-10238877a6a4","slug":"202009-raspi-os","title":"Raspberry PiでDiscordボットを作る(1) OSセットアップ","tags":[{"id":"ifpao4fqr","name":"ハードウェア","slug":"hardware"},{"id":"gdldpnony","name":"環境構築","slug":"environment"}],"coverimage":{"url":"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/image-644x433.png"},"summary":"Raspberry Piで、Discordボットを作るシリーズの第１弾です。\n今回はRaspberry Pi本体と必要な機材の説明と、Raspberry Pi OSの\nセットアップ方法の説明になります。","body":"<p>今回はRaspberry PiにLinux系OSをセットアップし、同じWi-fiネットワークにつながったPCからリモートログインできるようにするまでの手順を示します。<br></p><h2 id=\"hacedadb39e\">用意するハードウェア</h2><p>Raspberry Pi本体、Micro SDメモリカード(SDHC, 16GB以上推奨)と、Raspberry Pi用ケースを用意します。<br>今は教育用にRaspberry Piを使うのが大流行りのようで、Amazonで探すと<a href=\"https://www.amazon.co.jp/s?k=raspberry+pi+4\" target=\"_blank\" rel=\"noopener noreferrer\">Raspberry Pi用ケースやMicro SDカード付きのセット</a>が大量に見つかります。<br>セットアップ時には外付けキーボードとPC用ディスプレイ(またはテレビ)も必要です。<br></p><h2 id=\"h69dd53aa05\">Raspberry Pi OSをダウンロード</h2><p>空のMicroSDメモリカードをPCに挿入し、<a href=\"https://www.sdcard.org/jp/downloads/formatter/\" target=\"_blank\" rel=\"noopener noreferrer\">SDカードフォーマッター</a>でフォーマットします。フォーマットの実行と並行して、<a href=\"https://www.raspberrypi.org/downloads/\" target=\"_blank\" rel=\"noopener noreferrer\">Raspberry Pi財団のサイト</a>からRaspberry Pi OSとRaspberry Pi Imagerをダウンロードします。</p><h3 id=\"ha032940786\">Raspberry Pi OSのイメージ、どれがいい?</h3><p>今回のサーバ用途では、最小構成(デスクトップ環境なし)でも十分です。<br></p><h2 id=\"h6833811c65\">イメージのチェックサム確認(オプション)</h2><p>大きなファイルをダウンロードしたとき、まれに回線のノイズなどによりファイルが壊れてしまう場合があります。<br>ファイルが壊れているかを確かめる方法に、以下に述べる「チェックサムの確認」があります。<br>Raspberry Pi OSのダウンロードページの「Download ZIP」ボタンの下に「SHA-256」と英数字の文字列があります。<br>これはイメージファイルが正常にダウンロードされたかを確かめるための「チェックサム」と呼ばれるデータです。<br>ダウンロードしたファイルをLinux上 (Windows WSLでも可) で、以下のコマンドを入力して数分待つと、ダウンロードしたファイルのチェックサムが表示されます。</p><pre><code> shasum -a 256 2020-08-20-raspios-buster-armhf-lite.zip</code></pre><p>表示されたチェックサムがダウンロードページ内に記されたものと同じであれば、ダウンロード成功です。<br></p><h2 id=\"h765eec90b0\">Micro SDカードへの書き込み</h2><p>ダウンロードしたRaspberry Pi Imagerをインストールします。Raspberry Pi Imagerを起動して[Choose OS]ボタンを押して[Operation System]の一番下にある[Use Custom]を選んで、別途ダウンロードしたイメージファイルを開きます。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/image-644x433.png\" alt><br><br>[CHOOSE SD CARD]でPCに挿入したMicro SDカードを選び、[WRITE]で書き込みを行います。書き込み処理は場合にもよりますが数分から数十分ほどかかります。</p><h2 id=\"h375153af28\">Raspberry Pi本体の起動</h2><p>書き込みが終わったらPCからmicro SDカードを取り出し、Raspberry Piにmicro SDカードを挿入します。<br>基板の裏側、LANコネクタの反対側にmicro SD用挿入口があります。<br><br><img src=\"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/IMG_20200913_101335.jpg?w=345&h=460\" alt=\"Raspberry Piの裏側、Ethernetコネクタの反対\"><br><br>Micro SDカードを挿入したらキーボードとディスプレイを接続し、本体のUSBタイプCコネクタに電源用USBケーブルを接続して起動します。<br>起動すると初回のセットアップ画面が出ますので国と言語、パスワードとWi-fiの設定をします。<br>各種ソフトウェアのアップデートを勧められますので、アップデートもやっておきましょう。<br></p><h2 id=\"h6eb60043c6\">ネットワークログインの設定</h2><p>ネットワークログインの設定は、前回の自作機と同様にマルチキャストDNS(avahi-daemon)とSSHの有効化によって行います。SSHはルートディレクトリ直下にsshディレクトリを置くことで有効化できます。</p><pre><code>sudo apt install avahi-daemon\nsudo mkdir &#x2F;ssh</code></pre><p>マルチキャストDNSのホスト名はデフォルトでraspberrypiになっていますが、他のRaspberry Piと被らないようホスト名を変えておきます。</p><pre><code>sudo nano &#x2F;etc&#x2F;hostname</code></pre><p>ここまで完了したら再起動して、PCのSSHクライアント (WSL環境またはMacのターミナルのSSH、またはTeraTermなど) からログインをしてみましょう。<br>SSHクライアントの設定は</p><pre><code>ホスト名 : &lt;&#x2F;etc&#x2F;hostnameで設定した名前&gt;.local\nユーザー名 : pi\nポート番号 ：22</code></pre><p>でログインできるはずです。<br></p>"}},{"node":{"id":"c91c5e4f-e345-515b-878e-27afe94e0045","slug":"202009-first-post","title":"テスト記事","tags":[],"coverimage":{"url":"https://images.microcms-assets.io/protected/ap-northeast-1:9e5272dd-7b4e-43ed-93af-2c67006519ff/service/og-blog/media/20200915212419678.png"},"summary":"初めての記事です。","body":"<p>はじめまして。初投稿です。</p>"}}]}},"pageContext":{"limit":10,"skip":0,"numPages":1,"currentPage":1}},"staticQueryHashes":["272570591","3000541721","3649515864"]}